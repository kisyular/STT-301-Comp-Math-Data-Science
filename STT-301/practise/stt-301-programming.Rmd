---
title: "STT 301 R-Programming"
author: "Rellika Kisyula"
date: "9/11/2018"
output:
  html_document:
    fig_caption: yes
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

# 3.0 Scripts, R Markdown, and reproducible research

## 3.1 Scripts in R
Just choose `File > New File > New script` and a script window will open up in the upper left of the full RStudio window.
```{r}
u <- "http://blue.for.msu.edu/FOR875/data/WorldBank.csv"
WorldBank <- read.csv(u, header = TRUE, stringsAsFactors = FALSE)
names(WorldBank)
```

We will try to create a scatter plot of fertility rate versus life expectancy of countries for the year 1960.
```{r}
fertility <- WorldBank$fertility.rate[WorldBank$year == 1960]
lifeexp <- WorldBank$life.expectancy[WorldBank$year == 1960]
fertility[1:10]
plot(lifeexp, fertility)

```

```{r}
pop <- WorldBank$population[WorldBank$year == 1960]
region <- WorldBank$region[WorldBank$year == 1960]
```
First we will create the axes, etc. for the plot, but not plot the points, `type="n"` tells R to do this.
```{r}
plot(lifeexp, fertility, type="n")
symbols(lifeexp, fertility, circles=sqrt(pop/pi), inches=0.35, bg=match(region, unique(region)))
```

## 3.2 R Markdown
R Markdown provides a way to include R code that read in data, create graphics, or perform analyses, in a single document which is processed to create a research paper or homework assignment or other written product.

## 3.3 Basic formatting:
*italic*
**bold**
> block quote

~~strikethrough~~
A code chunk:
```{r}
x <- 1:10
y <- 10:1
mean(x)
sd(y)
```
Inline code:
`r 5+5`
Inline code not executed:
`5+5`

### 3.31 Text: Lists and Headers
For an unordered list, either an asterisk, a plus sign, or a minus sign may precede list items.

For an ordered list use a numeral followed by a period and a space (1. or 2. or 3. or ...) For an ordered list, the first list item will be labeled with the number or letter that you specify, but subsequent list items will be numbered sequentially.

**An unordered list:**

* List item 1
* List item 2
    + Second level list item 1
    + Second level list item 2
        + Third level list item
* List item 3

**An ordered list:**

1. List item 1
2. List item 2
    c. Sub list item 1
    q. Sub list item 2
17. List item 3

use # to indicate headers. `# A first *level* ~~header~~`  `## A second level header`

**Text subscripts and superscripts:**
x~2~ + y~2~
10^3^ = 1000
Mathematics examples:
$x_a$  
$x^a$  
 

## 3.4 Code Chunks
`echo=FALSE` specifies that the R code should not be printed (but any output of the R code should be printed) in the resulting document.

2. `include=FALSE` specifies that neither the R code nor the output should be printed. However, the objects created by the code chunk will be available for use in later code chunks.

3. `eval=FALSE` specifies that the R code should not be evaluated. The code will be printed unless, for example, echo=FALSE is also given as an option.
4. error=FALSE and warning=FALSE specify that, respectively, error messages and warning messages generated by the R code should not be printed.

5. The `comment` option allows a specified character string to be prepended to each line of results. By default this is set to `comment = ##` which explains the two hash marks preceding results in Figure 3.3 for example. Setting `comment = NA` presents output without any character string prepended. That is done in most code chunks in this book.

6. `prompt=TRUE` specifies that R prompt > will be prepended to each line of R code shown in the document. `prompt = FALSE` specifies that command prompts should not be included.

7. `fig.height` and `fig.width` specify the height and width of figures generated by R code. These are specified in inches, so for example fig.height=4 specifies a four inch high figure.

8. `code` Set to R code. Knitr will replace the code in the chunk with the code in the code option.

9. `engine` 'R' Knitr will evaluate the chunk in the named language, e.g. `engine = 'python'`.

10. `collapse` If `TRUE`, knitr will collapse all the source and output blocks created by the chunk into a single block.

11. `results` 'markup' If `'hide'`, knitr will not display the codeâ€™s results in the final document. If `'hold'`, knitr will delay displaying all output pieces until the end of the chunk. If `'asis'`, knitr will pass through results without reformatting them (useful if results
return raw HTML, etc.)

12. `error` If FALSE, knitr will not display any error messages generated by the code.

13. `message` If FALSE, knitr will not display any messages generated by the code.

14. `warning` If FALSE, knitr will not display any warning messages generated by the code.

15. `strip.white` If TRUE, knitr will remove white spaces that appear at the beginning or end of a code chunk.

16. `autodep` If TRUE, knitr will attempt to figure out dependencies between chunks automatically by analyzing object names.

17. `cache` If TRUE, knitr will cache the results to reuse in future knits. Knitr will reuse the results until the code chunk is altered.

18. `cache.comments` NULL If FALSE, knitr will not rerun the chunk if only a code comment has changed.



# 4.0 Data Structures

## 4.1 Vectors
Think of a vector as a structure to represent one variable in a data set. For example

**Vectors in R can only contain elements of one type.**
a vector might hold the weights, in pounds, of 7 people in a data set.
```{r echo=TRUE}
weight <- c(123, 157, 205, 199, 223, 140, 105)
weight
```

```{r}
gender <- c("female", "female", "male", "female", "male", "male", "female")
gender
```
**Notice that elements of a vector are separated by commas when using the `c()` function to create a vector.**


The `c()` function also can be used to add to an existing vector. add at the last element.
```{r}
weight <- c(weight, 194)
weight
gender <- c(gender, "male")

gender
```

### 4.11 Types, conversion, coercion

```{r}
typeof(weight)
```

```{r}
typeof(gender)
```

```{r}
bp <- c(FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
bp
typeof(bp)

as.character(bp)
as.numeric(bp)

is.character(bp)

char_bp = as.character(bp)
is.character(char_bp)
```

```{r}
weight.int <- as.integer(weight)
weight.int
```

```{r}
weight.char <- as.character(weight)
weight.char
```

```{r}
bp.double <- as.double(bp)
bp.double
```

### 4.12 Coercion

Values are converted to the simplest type to represent all the information
**Character > complex > double > integer > logical**
```{r}
c(4 + 3i, TRUE, "red", 6) # will become character
c(4 + 3i, TRUE, 4/5, 6) # will become complex
c(4 + 3, TRUE, 4/5, 6.0) # will become double
c(4 + 3, TRUE, 6) # will become Integer
```

```{r}
yy <- c(1, 2, 3, "dog")
yy
```

### 4.13 Accessing specific elements of vectors
```{r}
weight[5]
weight[1:3]
length(weight)
weight[length(weight)]

weight[3] <- 200000
weight
```

**Negative numbers in the square brackets tell R to omit the corresponding value.**

```{r}
weight[-3]
lessWeight <- weight[-c(1, 3, 5)]
lessWeight
weight
```

## 4.2 Factors
Categorical variables such as `gender` can be represented as character vectors. In many cases this simple representation is sufficient.
**Factors in R provide a more sophisticated way to represent categorical variables.**

```{r}
age <- c("middle age", "senior", "middle age", "senior", "senior", "senior", "senior", "middle age")
age

income <- c("lower", "lower", "upper", "middle", "upper", "lower", "lower", "middle")
income

age <- factor(age, levels=c("youth", "young adult", "middle age", "senior"))
age
```

```{r}
income <- factor(income, levels=c("lower", "middle", "upper"),ordered = TRUE)
income
```

### 4.14 Vector Recycling

```{r}
x = c(2,3,4)
y = c(5,6,7)
y + x
```

```{r}
x_small = c(1,2,3)
y_big = c(1,2,3,4,5,6)
 
x_small + y_big
```

```{r}
x <- weight
x <- c(x, NA, NA)
sum(is.na(x))
x[100]
x = 1:10
mean(na.rm=FALSE, x, trim=0)
```

```{r}
y <- mpg[, 2]
```







```{r}
dim(mpg)
z <- rep(0, length = dim(mpg)[2])
for (i in 1:dim(mpg)[2]){
    z[i] <- sum(mpg[, i] < 5)}
z
```

```{r}
a <- c(3, 6, 9, 12)
b <- matrix(c(1:4), nrow = 2, ncol = 2)
c <- c("good", "bad", "indifferent")
my.list <- list(a, b, c)
my.list

 my.list[[1]][3]
  my.list[[2]][2, ]
```




## 4.3 Missing Data, Infinity,

```{r}
missingCharacter <- c("dog", "cat", NA, "pig", NA, "horse")
missingCharacter
is.na(missingCharacter)
```

**remove the missing value(s) and then perform the computation.**
```{r}
mean(c(1, 2, 3, NA, 5), na.rm = TRUE)
```

**1. NaN` represents the result of a calculation where the result is undefined, such as dividing zero by zero.**

**2. ### Inf and -Inf represent infinity and negative infinity (and numbers which are too large in magnitude to be represented as floating point numbers).**

## 4.5 Data Frames
data is rectangular in form, with variables as columns and cases as rows.

```{r}
gender <- c("female", "female", "male", "female", "male", "male", "female")
bp <- c(FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE)
weight <- c(123, 157, 205, 199, 223, 140, 105)

healthData <- data.frame(Weight = weight, Gender=gender, bp.meds = bp,  stringsAsFactors=FALSE)

healthData
```

```{r}
names(healthData)
colnames(healthData)
names(healthData) <- c("Wt", "Gdr", "bp")
healthData
```

```{r}
rownames(healthData)
names(healthData) <- c("Weight", "Gender", "bp.meds")
healthData
```

### 4.5.1 Accessing specific elements of data frames
Data frames are two-dimensional, so to access a specific element (or elements) we need to specify both the row and column.

```{r}
data(mtcars)
head(mtcars)
```

```{r}
mtcars[3, 4]
row.names(mtcars)
mtcars[1:3, 2:3]
mtcars["cyl"]
```


**Note that mtcars[,1] returns ALL elements in the first column.**
```{r}
mtcars[, 1]
```


**For a data frame there is another way to access specific columns, using the $ notation.**
```{r}
mtcars$mpg
```

## 4.6 Lists

---

Technically a list is a vector, but one in which elements can be of different types.

---

**Key Properties:**

  + Heterogenous
  + Index by position/name `my_list[[2]]`
    + `my_list[2]` will return 2 element as list
  + Index with multiple position and names
  + Have names
  
---
**`The lm function returns a list`**

```{r}
mpgHpLinMod <- lm(mpg ~ hp, data = mtcars)
mode(mpgHpLinMod)
names(mpgHpLinMod)
mpgHpLinMod
mpgHpLinMod$coefficients
```

The list function is used to create lists.
```{r}
temporaryList <- list(first=weight, second=healthData, pickle=list(a = 1:10, b=healthData))

temporaryList$first
temporaryList[[1]]
temporaryList[[1]][1]
temporaryList$second

temporaryList[c(1, 2)] # returns a list with 1st and 2nd elements
temporaryList[[c(1, 2)]]
```

```{r}
temporaryList[2]
```

```{r}
my_list = list(1, 2, 3, c(3, 5, 6), c("a", "b", "c"))
my_list[1]
my_list[[4]][1]

my_list[[c(4, 2)]]
```

## 4.7 Subsetting with logical vectors
```{r}
weight
gender
gender[weight > 200]
```

### 4.7.1 Modifying or creating objects via subsetting
```{r}
lightweight <- weight[weight < 200]
lightweight

x <- 1:10
x

x[x < 5] <- 0
x
```

### 4.7.2 Logical subsetting and data frames
Example:
```{r}
x = c(-3:3)
x

z <- c(T, F, F, T, F, F, F)
x[z]
```

** We can use `<, >, ==, >=, <= !=` to create conditions with `&` and `I` **

```{r}
healthData
healthData$Weight[healthData$Gender == "male"]
healthData[healthData$Weight > 190, 2:3]
```

```{r}
temporaryDataFrame <- data.frame(V1 = c(1, 2, 3, 4, NA), V2 = c(NA, 1, 4, 5, NA), V3 = c(1, 2, 3, 5, 7))
temporaryDataFrame
is.na(temporaryDataFrame)
rowSums(is.na(temporaryDataFrame))
colSums(is.na(temporaryDataFrame))
```

## 4.8 Patterned data

The seq() function generates either a sequence of pre-specified length or a sequence with pre-specified increments.
```{r}
seq(from = 0, to = 1, length = 11)
seq(from = 1, to = 5, by = 1/3)
```

The rep() function replicates the values in a given vector.
```{r}
rep(c(1, 2, 4), length = 9)
rep(c(1, 2, 4), times = 3)
rep(c("a", "b", "c"), times = c(3, 2, 7))
```

# Functions and Programming
Learning about R's programming capabilities is an important step in gaining facility with functions.

## 7.1 R functions

```{r}
u.corn <- "http://blue.for.msu.edu/FOR875/data/corn.csv"
corn <- read.csv(u.corn, header = TRUE)
corn
```

```{r}
paired_t <- function(x1, x2) {
  n <- length(x1)
  dbar <- mean(x1 - x2)
  s_d <- sd(x1 - x2)
  tstat <- dbar/(s_d/sqrt(n))
  pval <- 2 * (1 - pt(abs(tstat), n - 1))
  margin <- qt(0.975, n - 1) * s_d/sqrt(n)
  lcl <- dbar - margin
  ucl <- dbar + margin
  return(list(tstat = tstat, pval = pval, lcl = lcl, ucl = ucl))
}

paired_t(x1 = corn$kiln_dried, x2 = corn$regular)
```
### 7.1.1 Creating functions
A function can be written in any text editor, saved as a plain text file (possibly with a .r extension), and then read into R using the source() function.


## 7.2 Programming: Conditional Statements
The argument to the `if()` function is evaluated. If the argument returns `TRUE` the ensuing code is executed.

### 7.2.1 Comparison and logical operators
```{r}
c(FALSE, TRUE, FALSE) || c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
```


### 7.2.2 If else statements
```{r}
Sign <- function(x) {
  if (x < 0) {
     print("the number is negative")
  }else if (x > 0) {
    print("the number is positive")
  }else {
    print("the number is zero")
  }
}
Sign(3)
Sign(-3)
Sign(0)
```

## 7.3 Computer Arithmetic
R does not perform exact arithmetic

```{r}
2^-30
2^-30 + (2^30 - 2^30)
(2^-30 + 2^30) - 2^30

1.5 - 1.4 == 0.1
all.equal((1.5 - 1.4), 0.1)
```

## 7.4 Loops
Loops are an important component of any programming language, including R. Vectorized calculations and functions such as apply() make loops a bit less central to R than to many other languages.


### 7.4.1 A repeat loop
A `repeat loop` just repeats a given expression over and over again until a break statement
is encountered.
```{r}
k <- 1
repeat {
  if (1 == 1 + 1/2^k){
    break
  }else {
    k <- k + 1
  }
}
k
```

### 7.4.2 A while loop
A while loop has the form
`while (condition) expression`
As long as the condition is `TRUE` the expression is evaluated. Once the condition is `FALSE` control is transferred outside the loop.

```{r}
k <- 1
while (1 != 1 + 1/2^k) {
  k <- k + 1
}
k
```

### 7.4.3 A for loop
A for loop has the form
`for (variable in vector) expression`
The for loop sets the `variable` equal to each element of the vector in succession, and evaluates the `expression` each time
```{r}
x <- 1:10
S <- 0

for (i in 1:length(x)){
  S <- S + x[i]
}
S
```

# 5.0 ggplot2
1. **gg** stands for **grammar of graphics**
2. **ggigraph** is an interactive graph
3. **ggrepel** overlapping text labels
4. **ggraph** graphs
5. **ggthemes** themes

#####Template
`ggplot ( data =<dataframe>,` 
  `mapping = aes(<Mappings1>)) +`
  `<Geom_fen>(aes(<Mappings2>)) +`
  `<Facet_function>`
      `facet_wrap(~var)`
      `facet_grid(~var1, var2) +`
  `labs (x, y, title, caption, subtitle, color, size)`
  
##### Examples
```{r}
data("mtcars")
ggplot(data = mtcars,
       mapping = aes(x=hp, y=mpg)) +
  geom_point(aes(color = factor(cyl),
                 shape = factor(am)),
             size=5)

data("mtcars")
ggplot(data = mtcars,
       mapping = aes(x=hp, y=mpg)) +
  geom_point(aes(color = factor(cyl),
                 shape = factor(am)),
             size=5) +
  facet_wrap(~factor(cyl))
```

## 5.1 Scatter Plots
Scatter plots are a workhorse of data visualization and provide a good entry point to the ggplot2 system.

```{r}
data(iris)
str(iris)
```

```{r}
library(ggplot2)
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
       geom_point()
```

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
       geom_point(size = 4, aes(color=Species, shape=Species))
```

### 5.1.2 Adding lines to a scatter plot
```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
       geom_point(size=3, aes(color=Species)) +
       stat_smooth(method = lm, se=FALSE)
```

For the iris data, it probably makes more sense to fit separate lines by species. This
can be specified using the aes() function inside `stat_smooth()`.

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
      geom_point(size=3, aes(color=Species)) +
      stat_smooth(method = lm, se=FALSE, aes(color=Species))
```

Another common use of line segments in a graphic is to connect the points in order,
accomplished via the geom_line() function.

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
      geom_point(size = 4, aes(color=Species, shape = Species)) +
      geom_line()


      ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
      geom_point(size = 4, aes(color=Species)) +
      geom_line(aes(color=Species))
```


## 5.2.0 Labels, axes, text, etc.
```{r}
u.crime <- "http://blue.for.msu.edu/FOR875/data/crimeRatesByState2005.csv"
crime <- read.csv(u.crime, header=TRUE)
str(crime)
```
Here we use `labs()` to change the x and y axis labels and other descriptive text.

```{r}
ggplot(data = crime, aes(x = burglary, y = motor_vehicle_theft)) +
  geom_point() +
  labs(x = "Burglaries per 100,000 population",
       y = "Motor vehicle theft per 100,000 population",
       title = "Burglaries vs motor vehicle theft for US states",
       subtitle = "2005 crime rates and 2008 population",
       caption = "Data from Nathan Yau http://flowingdata.com"
)
```

### 5.2.1 Customizing axes
`ggplot` also provides default axis extents (i.e., limits) and other axis features. These, and other axis features such as tick marks, labels, and transformations, can be changed using the scale functions

```{r}
ggplot(data = crime, aes(x = burglary, y = motor_vehicle_theft)) +
  geom_point() +
  scale_x_continuous(name="Burglaries per 100,000 population",
                    limits=c(0,max(crime$burglary))) +
  scale_y_continuous(name="Motor vehicle theft per 100,000 population",
                      limits = c(0, max(crime$motor_vehicle_theft)))
```

### 5.2.2 Text, point size, and color

```{r}
ggplot(data = crime, aes(x = burglary, y = motor_vehicle_theft,
       size=population/100000)) +
       geom_point(color = "blue") +
       geom_label(aes(label = state), alpha = 0.5) +
       scale_x_continuous(name="Burglaries per 100,000 population",
                     limits=c(0,max(crime$burglary))) +
        scale_y_continuous(name="Motor vehicle theft per 100,000 population",
                     limits = c(0, max(crime$motor_vehicle_theft))) +
        labs(size="Populationnn(100,000)")
```


```{r}
library(ggrepel)
ggplot(data = crime, aes(x = burglary, y = motor_vehicle_theft,
      size=population/100000)) +
      geom_point(color = "blue") +
      scale_x_continuous(name="Burglaries per 100,000 population",
                    limits=c(0,max(crime$burglary))) +
      scale_y_continuous(name="Motor vehicle theft per 100,000 population",
                  limits = c(0, max(crime$motor_vehicle_theft))) +
      labs(size="Populationnn(100,000)") +
       ggrepel::geom_label_repel(aes(label = state), alpha = 0.5)
```


geom_raster: heatmap (x,y)
geom_density: density plot

### 5.3.1 Histograms
Simon Newcomb conducted several experiments to estimate the speed of light by measuring the time it took for light to travel from his laboratory to a mirror at the base of the Washington Monument, and then back to his lab.

```{r}
u.newcomb <- "http://blue.for.msu.edu/FOR875/data/Newcomb.csv"
Newcomb <- read.csv(u.newcomb, header = TRUE)
head(Newcomb)

ggplot(Newcomb, aes(x = Time)) + geom_histogram()
```
```{r}
ggplot(Newcomb, aes(x = Time)) +
geom_histogram(binwidth = 5, color = "black", fill = "blue" )
```

### 5.3.2 Boxplots
```{r}
library(gapminder)
ggplot(data = subset(gapminder, year == 2002),
     aes(x = continent, y = gdpPercap)) +
  geom_boxplot(color = "black", fill = "lightblue")
```

```{r}
ggplot(data = subset(gapminder, year == 2002),
    aes(x = continent, y = gdpPercap)) +
  geom_boxplot(color = "red", fill = "lightblue") +
  scale_x_discrete(name = "Continent") +
  scale_y_continuous(name = "Per Capita GDP") + coord_flip()
```

### 5.3.3 Bar graphs
As part of a study, elementary school students were asked which was more important to them: good grades, popularity, or athletic ability. Here is a brief look at the data.
```{r}
u.goals <- "http://blue.for.msu.edu/FOR875/data/StudentGoals.csv"
StudentGoals <- read.csv(u.goals, header = TRUE)
head(StudentGoals)
```
First a simple bar graph of the most important goal chosen is drawn, followed by a stacked bar graph which also includes the student's gender, followed by a side by side bar graph which includes the student's gender.

```{r}
ggplot(StudentGoals, aes(x = Goals)) + geom_bar()
ggplot(StudentGoals, aes(x = Goals, fill = Gender)) + geom_bar()
ggplot(StudentGoals, aes(x = Goals, fill = Gender)) +
  geom_bar(position = "dodge")
```

In this example R counted the number of students who had each goal and used
these counts as the height of the bars. Sometimes the data contain the bar heights as a variable. For example, we create a bar graph of India's per capita GDP with separate bars for each year in the data

```{r}
ggplot(subset(gapminder, country == "India"), aes(x = year, y = gdpPercap)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue2") +
  ggtitle("India's per-capita GDP")
```

### 5.3.4 Graphs of functions
```{r}
x <- seq(-pi, pi, len = 1000)
sin.data <- data.frame(x = x, y = sin(x))
ggplot(data = sin.data, aes(x = x, y = y)) + geom_line() +
  scale_y_continuous(name = "sin(x)")
```

## 5.4 Themes
Default themes include: `theme_bw()`, `theme_classic()`, `theme_dark()`, `theme_gray()`, `theme_light()`, `theme_linedraw()`, `theme_minimal()`, and `theme_void()`.

```{r}
ggplot(data = sin.data, aes(x = x, y = y)) + geom_line() +
  scale_y_continuous(name = "sin(x)") +
  theme_classic()
```

The ggthemes add-on package https://github.com/jrnold/ggthemes by Jefrey Arnold provides a large selection of themes beyond the eight themes that come with ggplot2

## 5.5 Saving graphics
formats. The `ggsave()` function will allow you to save your most recent `ggplot()` to a variety of vector (e.g., "eps", "ps", "pdf", "svg") or raster (e.g., "jpeg", "tif", "png", "bmp", "wmf") formats. The subsequent call to `ggsave()` saves the`sin.data plot` to a pdf file called "sin-plot.pdf".

```{r}
ggplot(filename = "sin-plot.pdf", device="pdf")
```


# Working with Data
This involves bringing data into R, exporting data from R in a form that is readable by other software, cleaning and reshaping data, and other data manipulation

## 6.1 Reading data into R
Data come in a dizzying variety of forms. It might be in a proprietary format such as an .xlsx Excel file, a .sav SPSS file, or a .mtw Minitab file.

The `read.table()` function is used to read these data into an R data frame.
```{r}
u.bb <- "http://blue.for.msu.edu/FOR875/data/BrainAndBody.csv"
BrainBody <- read.table(file = u.bb, header = TRUE, sep = ",",
stringsAsFactors = FALSE)
head(BrainBody)
```

The arguments used in this call to `read.table()` include:

1. `file = u.bb`, which tells R the location of the file.
2. `header = TRUE`, which tells R the first line of the file gives the names of the variables.
3. `sep = ","`, which tells R that a comma separates the fields in the file.
4. `stringsAsFactors = FALSE` which tells R not to convert character vectors to factors.

The function `read.csv()` is the same as read.table() except the default separator is a comma, whereas the default separator for `read.table()` is whitespace.

The file [BrainAndBody.tsv](http://blue.for.msu.edu/FOR875/data/BrainAndBody.tsv) contains the same data, except a tab is used in place
of a comma to separate fields.

```{r}
u.bb <- "http://blue.for.msu.edu/FOR875/data/BrainAndBody.tsv"
BrainBody <- read.table(file = u.bb, header = TRUE, sep = "\t",
stringsAsFactors = FALSE)
head(BrainBody)
```

A third file, [BrainAndBody.txt]("http://blue.for.msu.edu/FOR875/data/BrainAndBody.txt"), contains the same data, but also contains a fewnlines of explanatory text above the names of the variables. It also uses whitespacen rather than a comma or a tab as a separator.

```{r}
u.bb <- "http://blue.for.msu.edu/FOR875/data/BrainAndBody.txt"
BrainBody3 <- read.table(u.bb, header = TRUE, sep = " ", stringsAsFactors = FALSE, skip = 4)
BrainBody3[1:10,]
```

### 6.1.1 Reading data with missing observations
The read.table() function has an argument `na.string` which allows the user to specify how missing data is indicated in the source file.

Argument `na.string = ""` which tells R the file indicates missing data by leaving the appropriate entry blank.
```{r}
u.weather <- "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014.csv"
WeatherKLAN2014 <- read.csv(u.weather, header=TRUE, stringsAsFactors = FALSE, na.string = "")

WeatherKLAN2014[1:15,]
```

## 6.2 Summarizing data frames
Some common data tasks include variable summaries such as means or standard deviations, transforming an existing variable, and creating new variables.

### 6.2.1 Column (and row) summaries
```{r}
u.weather <- "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014Full.csv"
WeatherKLAN2014Full <- read.csv(u.weather, header=TRUE, stringsAsFactors = FALSE, na.string = "")
names(WeatherKLAN2014Full)
```

#### 6.2.1.1 Mean
To compute `mean()` for each column we can:
```{r}
mean(WeatherKLAN2014Full$Mean.TemperatureF)
mean(WeatherKLAN2014Full$Min.TemperatureF)
mean(WeatherKLAN2014Full$Max.TemperatureF)
## Et Cetera
```

However, this wastes a lot of time. We can save time by using `colMeans()` function which computes the mean of each (or specified) columns in a data frame.

```{r}
colMeans(WeatherKLAN2014Full[, c(2:19, 21, 23)])
```

### 6.2.2 The `apply()` function
R also has functions `rowMeans()`, `colSums()`, and `rowSums()`.
The function `apply()` function applies a user-chosen function to either the rows or columns (or both) of a data frame. The arguments are X, the data frame of interest, MARGIN, specifying either rows (MARGIN = 1) or columns (MARGIN = 2), and FUN, the function to be applied.

```{r}
apply(X = WeatherKLAN2014Full[, c(2:19, 21, 23)], MARGIN = 2,FUN = sd)
```

### 6.2.3 Saving typing using `with()`
The `with()` function tells R that we are working with a particular data frame, and we don't need to keep typing the name of the data frame.

```{r}
with(WeatherKLAN2014Full, mean(Max.TemperatureF[CloudCover <4 & Max.Humidity > 85]))
```

#### 6.2.3.1 More examples
```{r}
m <- matrix(c(1:9), nrow = 3, ncol = 3)
m
```
**To calcutalte sum of each columns we can:**
```{r}
sum(m[,1])
sum(m[,2])
sum(m[,3])
## or
 colSums(m)
```

**A better way is to use `apply()` function**
*Syntax* apply(x, MARGIN, FUN)
**x** data
**MARGIN** how to apply the function
        1 = rows
        2 = columns
**FUN** the function to apply
```{r}
apply(X=m, MARGIN=2,FUN=sum)
```

What if your function requires multiple arguments?
USE:

example: Consider m and z where z = c(1,2,3)
Compute the correclation between z and each column of m
cor(x, y)
apply(m, 2, cor, y=z)

if MARGIN = c(1, 2), apply the function on both rows and columns

`l`,`s`,`t` apply
If you have a list and you want to apply a function to each element of the list, USE:
`lapply(X, FUN, ...)` returns a list
`lapply(X, FUN, ...)` returns a vector/matrix

If you want to process data by groups, use tapply
`tapply (X, INDEX, FUN, ...)`
INDEX â‰  group factor (levels/groups)


## 6.3 Transforming a data frame
Commonly variables are added to, removed from, changed in, or rearranged in, a data frame.

```{r}
library(gapminder)
str(gapminder)
```

### 6.3.1 Adding variables
The data frame contains `per capita GDP` and `population`, and it might be interesting to create a variable that gives the `total GDP` by multiplying these two variables.

```{r}
gapminder$TotalGDP <- gapminder$gdpPercap * gapminder$pop
str(gapminder)
```

Analogous to the `with()` function, there is a function `within()` which can simplify the syntax. Whereas `with()` does not change the data frame, `within()` can. Note, below I first remove the altered gapminder dataframe using `rm()` then bring a clean copy back in by reloading the gapminder package.

```{r}
rm(gapminder)
library(gapminder)
str(gapminder)
```

```{r}
gapminder <- within(gapminder, TotalGDP <- gdpPercap * pop)
str(gapminder)
```


A nice feature of `within()` is its ability to add more than one variable at a time to a data frame. In this case the two or more formulas creating new variables must be enclosed in braces.

```{r}
gapminder <- within(gapminder, {TotalGDP <- gdpPercap * pop 
lifeExpMonths <- lifeExp * 12})
str(gapminder)

```

### 6.3.2 Removing variables
After reflection we may realize the new variables we added to the `gapminder` data frame are not useful, and should be removed.

```{r}
str(gapminder)
```

```{r}
gapminder <- gapminder[1:6]
str(gapminder)
```

The same result could be obtained via `gapminder <- gapminder[, 1:6]`.

```{r}
a <- data.frame(x = 1:3, y = c("dog", "cat", "pig"), z = seq(from = 1,to = 2, length = 3))
a
```

```{r}
b <- a[1]
b
b <- a[, 1]
b

c <- a[-(2:3)]
c

#d <- a[-2:3]
```

One can also use a negative sign in front of the variable number(s). For example, `a[-(2:3)]` would drop the first two columns of a.

### 6.3.3 Transforming variables
Imagine we want to modify the existing variable to measure life expectancy in months.


```{r}
rm(gapminder)
library(gapminder)
gapminder$lifeExp[1:5]

gapminder$lifeExp <- gapminder$lifeExp * 12
gapminder$lifeExp[1:5]
```


```{r}
rm(gapminder)
library(gapminder)
gapminder$lifeExp[1:5]

gapminder <- within(gapminder, lifeExp <- lifeExp * 12)
gapminder$lifeExp[1:5]

```


### 6.3.4 Rearranging variables
Consider the full weather data set again.

```{r}
u.weather <- "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014Full.csv"
WeatherKLAN2014Full <- read.csv(u.weather, header=TRUE,
                                stringsAsFactors = FALSE,
                                na.string = "")
names(WeatherKLAN2014Full)
```

If we want the wind speed variables to come right after the date, we can again use subsetting.

```{r}
WeatherKLAN2014Full <- WeatherKLAN2014Full[c(1, 17, 18, 19, 2:16,20:23)]
names(WeatherKLAN2014Full)

```

## 6.4 Reshaping data
A data set can be represented in several different formats. (Wide or Long)

### 6.4.1 Tidyr
The R library `tidyr` has functions for converting data between formats.
A tidy dataset has:
    1. Each variable has its own column
    2. Each observation has its own row
    3. Each value has its own cell
    
Useful tidy functions:
1. `gather()`
2. `unite()`
3. `separate()`
4. `spread ()`
```{r}
u.rel <- "http://blue.for.msu.edu/FOR875/data/religion2.csv"
religion <- read.csv(u.rel, header = TRUE, stringsAsFactors = FALSE)
head(religion)
```
#### 6.4.1.1 Examples of tidy tables
**1. TABLE 1**
```{r}
library(tidyr)

table1
```
**1. TABLE 2**
```{r}
table2
```
**1. TABLE 3**
```{r}
table3
```
**1. TABLE 4**
```{r}
table4a
```

The `gather()` function can transform data from wide to long format.
It is useful when variable is spread acrosss multiple columns

To use `gather()` we specified the data frame (`data = religion`), the name we want to give to the column created from the income levels (`key = IncomeLevel`), the name we want to give to the column containing the frequency values (`value = Frequency`) and the columns to gather (`2:11`).
```{r}
library(tidyr)
religionLong <- gather(data = religion, key = IncomeLevel, value = Frequency, 2:11)
head(religionLong)
```



```{r}
tail(religionLong)
```


When observation is scattered across multiple rows. We can use `spread()`. This changes the data from `Long -> wide format`
```{r}
religionWide <- spread(data = religionLong, key = IncomeLevel, value = Frequency)
head(religionWide)
```

Here we specify the data frame (`religionLong`), the column (`IncomeLevel`) to be spread, and the column of values (`Frequency`) to be spread among the newly created columns.


`tidyr` provides two other useful functions to separate and unite variables based on some deliminator. Consider again the `yearlyIncomeWide` table. Say we want to split the name variable into first and last name. This can be done using the `separate()` function. It is useful when cells have multiple values

```{r}
yearlyIncomeLong <- data.frame(name = c("John Son", "Jim Doe", "Sam Nil"), y = c("dog", "cat", "pig"), z = seq(from = 1,to = 2, length = 3))

firstLast <- separate(data = yearlyIncomeLong, col = name, into = c("first", "last"), sep="\\s")
print(firstLast)
```

If you want to combine the name column again, This is done using the `unite()` function. It is useful when a single value in multiple cells

```{r}
unite(firstLast, col = name, first, last, sep = "_")
```


#### Examples

```{r}
separate(data = table3, col = "rate", into = c("cases", "population"))
gather(table4a, key = "year", value = "cases", -1)

```


## 6.5 Manipulating data with dplyr

`mutate()` adds new variables that are functions of existing variables,
`select()` picks variables based on their names,
`filter()` picks cases based on their values,
`summarize()` reduces multiple values down to a single summary,
`arrange()` changes the ordering of the rows.

These all combine naturally with a `group_by()` that allows you to perform any operation grouped by values of one or more variables.


### 6.5.1 Improved data frames
`tbl_df()` creates a tibble3.

```{r}
library(dplyr)
```

```{r}
head(religionWide)
```

```{r}
religionWideTbl <- tbl_df(religionWide)
head(religionWideTbl)
```

### 6.5.2 Filtering data by row
The `read.delim()` function defaults to `header = TRUE`

The `filter()` is used to select rows based on certain criteria of columns varibles
```{r}
u.gm <- "http://blue.for.msu.edu/FOR875/data/gapminder.tsv"
gm <- read.delim(u.gm)
gm <- tbl_df(gm)

str(gapminder)
head(gm)
```


Filtering helps us to examine subsets of the data such as data from a particular country or from several specified countries, data from certain years, from countries with certain populations, etc. Some examples:
```{r}
filter(gm, country == "Brazil")
```

```{r}
filter(gm, country %in% c("Brazil", "Mexico"))
```


```{r}
filter(gm, country %in% c("Brazil", "Mexico") & year %in% c(1952, 1972))
```

```{r}
filter(gm, pop > 300000000)
```


```{r}
filter(gm, pop > 300000000 & year == 2007)
```


### 6.5.3 Selecting variables by column
The `select()` function will choose varibles of dataframe.

Variables can be selected by name or column number. As usual, a negative sign tells R to leave something out. And there are special functions such as `starts_with` that provide ways to match part of a variable's name.

```{r}
select(gm, country, year, lifeExp)
select(gm, 2:4)
select(gm, -c(2, 3, 4))
select(gm, starts_with("c"))
```


### 6.5.4 Pipes
Consider selecting the `country`, `year`, and `population` for countries in Asia or Europe. One possibility is to nest a `filter()` function inside a `select()` function.
```{r}
select(filter(gm, continent %in% c("Asia", "Europe")), country,year, pop)
```

There is a nice feature in dplyr that allows us to `feed` results of one function into the first argument of a subsequent function. The %>% operator does the piping.

```{r}
gm %>% filter(continent %in% c("Asia", "Europe")) %>% select(country, year, pop)
```

### 6.5.5 Arranging data by row
By default the `gapminder` data are arranged by country and then by year
The `arrange()` reoders the rows
```{r}
head(gm, 10)
```

Possibly arranging the data by year and then country would be desired. The
arrange() function makes this easy. We will again use pipes.
```{r}
gm %>% arrange(year, country)
```


How about the data for Rwanda, arranged in order of life expectancy.
```{r}
gm %>% filter(country == "Rwanda") %>% arrange(lifeExp)
```

Possibly we want these data to be in decreasing (descending) order. Here, `desc()` is one of many dplyr helper functions.
```{r}
gm %>% filter(country == "Rwanda") %>% arrange(desc(lifeExp))
```

Possibly we want to include only the year and life expectancy, to make the message more stark.
```{r}
gm %>% filter(country == "Rwanda") %>% select(year, lifeExp) %>% arrange(desc(lifeExp))
```

### 6.5.6 Renaming variables
The `dplyr` package has a `rename` function that makes renaming variables in a data frame quite easy.
```{r}
gm <- rename(gm, population = pop)
head(gm)
```

### 6.5.7 Data summaries and grouping
The `summarize()` function computes summary statistics or user provided function for one or more columns of data in a data frame.
```{r}
summarize(gm, meanpop = mean(population), medpop = median(population))
```


For example, we might want the median life expectancy for each continent separately. One option is subsetting:
```{r}
median(gm$lifeExp[gm$continent == "Africa"])
median(gm$lifeExp[gm$continent == "Asia"])
median(gm$lifeExp[gm$continent == "Europe"])
median(gm$lifeExp[gm$continent == "Americas"])
median(gm$lifeExp[gm$continent == "Oceania"])
```

The `group_by()` function makes this easier, and makes the output more useful.
```{r}
gm %>% group_by(continent) %>% summarize(medLifeExp = median(lifeExp))
```

Or if we want the results ordered by the median life expectancy:
```{r}
gm %>% group_by(continent) %>% summarize(medLifeExp = median(lifeExp)) %>% arrange(medLifeExp)
```


We can calculate the number of observations we have per continent (using the `n()` helper function),
```{r}
gm %>% group_by(continent) %>% summarize(numObs = n())
```

```{r}
gm %>% group_by(continent) %>% summarize(n_obs = n(), n_countries = n_distinct(country))
```


Here is a bit more involved example that calculates the minimum and maximum life expectancies for countries in Africa by year.
```{r}
gm %>% filter(continent == "Africa") %>% group_by(year) %>% summarize(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))
```


This is interesting, but the results don't include the countries that achieved the minimum and maximum life expectancies.
```{r}
gm %>% select(country, continent, year, lifeExp) %>% group_by(year) %>% arrange(year) %>% filter(rank(lifeExp) == 1)
```

Next we add the maximum life expectancy
```{r}
gm %>% select(country, continent, year, lifeExp) %>% group_by(year) %>% arrange(year) %>% filter(rank(lifeExp) == 1 | rank(desc(lifeExp)) == 1) %>% print(n=24)
```

### 6.5.8 Creating new variables
The `$` notation provides a simple way to create new variables in a data frame. The `mutate()` function provides another, sometimes cleaner way to do this. It is used to add a new variable to the dataframe
```{r}
gm %>% group_by(country) %>% mutate(changeLifeExp = lifeExp -
+ lag(lifeExp, order_by = year)) %>% select(-c(population,
+ gdpPercap))
```

### 6.5.5 Class Examples:
```{r}
data("mtcars")
mtcars <- as_tibble(mtcars)
mtcars
```
```{r}
filter(mtcars, cyl==6 & am ==1)
```

```{r}
arrange(mtcars, hp)
```

```{r}
ratio_mtcars <- mutate(mtcars, ratio = hp/mpg)
ratio_mtcars
```

```{r}
group_by(mtcars, cyl) %>% summarise(mean.hp =mean(hp))
```


# 8.0 Simulation
This chapter will provide a brief introduction to using R for simulationt

The purpose of simulations:
    1. Test statistical intuition
    2. Validate theory
    3. Experiemnt with a new technique
    
Generate random numbers from different distribution with r<dist> i.e 
        `rnorm`
        `rbinom`
        `rchi`

To generate from a finite populattion use `sample()`
`sample( X, size, replace=F, prob=NULL)`
X = vector of data to sample


**Monty Hall Ploblem**
Is it better to stay or switch doors? Or does it not matter?

## 8.1 Pseudo-random numbers
Simulations use numbers generated by a pseudo-random number generator (PRNG) rather than by a truly random number generator.

Linear congruential generators are a common starting point. A linear congruential generator requires a multiplier (a), an increment (c), a modulus (m), and a seed X0, all integers. The generator is defined by

$X_i = (aX_{i-1} + c)$ mod m:

Recall that Z `mod m` gives the remainder when Z is divided by `m`. In R Z mod m is implemented as `Z %% m`.

```{r}
15%%2
15%%5
15%%6
```

The function lcg() below implements this idea in R.
```{r}
lcg <- function(a, c, seed, m, iter) {
    out <- numeric(iter)
    out[1] <- seed
    for (i in 2:(iter)) {
        out[i] <- (a * out[i - 1] + c)%%m
    }
    return(out)
}
lcg(a = 65, c = 1, seed = 0, m = 2048, iter = 10)/2048
lcg(a = 1365, c = 1, seed = 0, m = 2048, iter = 10)/2048
lcg(a = 1229, c = 1, seed = 0, m = 2048, iter = 10)/2048
```

A very basic way to assess the performance of a PRNG is to draw a histogram of the values. The histogram should look like the histogram of uniformly distributed values.

```{r}
tmp_random <- data.frame(x = lcg(a = 1229, c = 1, seed = 0, m = 2048, iter = 2048)/2048)
ggplot(tmp_random, aes(x = x)) + geom_histogram(binwidth = 10)
```

Being able to provide a seed is important for repeatability of simulations. The `set.seed()` function in R provides this capability

```{r}
set.seed(123)
runif(5)

set.seed(123)
runif(5)

runif(5)
```

## 8.2 Simulating from standard distributions

For example suppose that we want to generate coin 
flips, i.e., to generate from a Bernoulli (0.5) distribution. Here is one way to do this.

```{r}
generate_coin <- function(n) {
    out <- rep(0, n)
    out[runif(n) > 0.5] <- 1
    return(out)
}
generate_coin(10)
```

If we wanted H and T for heads and tails, a similar method would work.
```{r}
generate_coin <- function(n) {
    out <- rep("T", n)
    out[runif(n) > 0.5] <- "H"
    return(out)
}
generate_coin(10)
```

R provides functions that give the density (or mass function), cumulative distribution function, quantile function, and generate values.

1. `dnorm` is the normal density function
2. `pnorm` is the normal cumulative distribution function
3. `qnorm` is the normal quantile function
4. `rnorm` generates values from a normal distribution

Rather than designing our own methods for simulating from these distributions, it is better to use the built in functions.

```{r}
# 10 values from the N(100, 2) distribution
rnorm(10, mean = 100, sd = 2)

# 5 values from the Uniform(-3, 4) distribution
runif(5, min = -3, max = 4)

# 7 values from the binomial(10, 0.2) distribution
rbinom(7, size = 10, p = 0.2)
```

In addition, the sample function provides a way to sample from a finite population.

```{r}
# 10 coin flips
sample(c("H", "T"), 10, replace = TRUE)

# a random permutation
sample(1:9, 9, replace = FALSE)

# sample from a distribution with P(X=2) = 0.3; P(X=3)=0.5;  and P(X=17)=0.2
sample(c(2, 3, 17), size = 15, replace = TRUE, prob = c(0.3, 0.5, 0.2))
```


## 8.3 Investigating `t` tests
Inverse CDF method (Inverse Transform Sampling)

Let X be our random variable of interest and assume X has CDF, $F_x(x)$

GOAL: Generate random varibles from X

ALGORITHM
1. Generate $U=Unif(0, 1)$
2. Find x such that $F_x(x) = U$
    => $x = F_x^-1 (U)$
    
Theorem: Let X have continous CDF and define the variable Y such that $Y=Unif(0,1)$
$Y = F_x(x)$
Then $Y = Unif(0,1)$

Proof: $P(Y=< y)$ = $P(F_x(x) =<y)$

Solve: $x_1 = F_x^-1 (U_i)$ U is uniform
$1-e^(z/x_1) = U_$
$-e^(-z/x_i) = u_i -1$
$x_i = -zln(i-u_i)$

You can control random number generation with `set.seed()`. R uses Mersenne Twitter algorithm to generate random numbers based off the seed

An Example:
    Algorithm
        1. Select a seed
        2. Multiply the seed by itself
        3. Output the middle number
        4. Use the result as the new seed
```{r}
seed = 14
seed * seed # 196 -> 19
19 * 19 # 361 -> 36
36 * 36 # 1296 - 29
```


# 9.0 Classifcation
Classifcation methods are both extremely useful and an active area of research in statistics. In this chapter we will learn about two common, and somewhat different, classification methods, logistic regression and k nearest neighbors

## 9.1 Logistic regression
We would like to predict the value of Y based on the value of the predictor X. Let `p(X) = P(Y = 1jX)`. We will model `p(X)` with the logistic function, which takes values between `0` and `1`, which is of
course appropriate for modeling a probability:
```{r}
library(ggplot2)
logistic <- function(x) {
    exp(x)/(1 + exp(x))
}
ggplot(data.frame(x = c(-6, 6)), aes(x)) + stat_function(fun = logistic)
```

```{r}
library(MASS)
head(Pima.tr)
```


It will be more convenient to code the presence or absence of diabetes by 1 and 0, so we first create another column in the data frame with this coding:
```{r}
Pima.tr$diabetes <- rep(0, dim(Pima.tr)[1])
Pima.tr$diabetes[Pima.tr$type == "Yes"] <- 1
head(Pima.tr)
```

In R we will use the function `glm` to fit logistic regression models The `glm` function fits a wide variety of models.

To specify the logistic regression model we specify `family = binomial` as an argument to glm.

1. predictor and response variables `(diabetes ~ glu)`
```{r}
diabetes.lr1 <- glm(diabetes ~ glu, data = Pima.tr, family = binomial)
diabetes.lr1
```

```{r}
summary(diabetes.lr1)
```

```{r}
beta0.lr.1 <- coef(diabetes.lr1)[1]
beta1.lr.1 <- coef(diabetes.lr1)[2]
beta0.lr.1
beta1.lr.1
```

The coefficients `b0` and `b1` are approximately `b0` = -5.504 and `b1` = 0:038.
So for example we can estimate the probability that a woman in this population whose glucose level is 150 would be diabetic as:

```{r}
exp(-5.504 + 0.038 * 150)/(1 + exp(-5.504 + 0.038 * 150))
```


We can plot the fitted probabilities along with the data `by hand.`
```{r}
diabetes.logistic.1 <- function(x){
    exp(beta0.lr.1 + beta1.lr.1 * x)/(1 + exp(beta0.lr.1 + beta1.lr.1 * x))
}
ggplot(Pima.tr, aes(x = glu, y = diabetes)) + 
    stat_function(fun = diabetes.logistic.1)+
    geom_point()
```
                                                            
                                                            
The ggplot2 package also provides a way to do this more directly, using `stat_smooth`.
```{r}
ggplot(Pima.tr, aes(x = glu, y = diabetes)) +
    geom_point() +
    stat_smooth(method = "glm", method.args = list(family = "binomial"), se = F)
```


From these graphics we can see that although glucose level and diabetes are related, there are many women with high glucose levels who are not diabetic, and many with low glucose levels who are diabetic, so likely adding other predictors to the model will help.


```{r}
head(Pima.te)
```

```{r}
diabetes.probs.1 <- predict(diabetes.lr1, Pima.te, type = "response")
head(diabetes.probs.1)
```

The predict function (with `type = "response"` specifed) provides `p(x) = P(Y = 1jX = x)` for all the `x` values in a data frame.

```{r}
diabetes.predict.1 <- rep("No", dim(Pima.te)[1])
diabetes.predict.1[diabetes.probs.1 > 0.5] <- "Yes"
head(diabetes.predict.1)
```


```{r}
length(diabetes.predict.1[diabetes.predict.1 == Pima.te$type])/dim(Pima.te)[1]
```


### 9.1.1 Adding predictors
We will next see how adding bmi, the body mass index, affects predictions of diabetes.

```{r}
diabetes.lr2 <- glm(diabetes ~ glu + bmi, data = Pima.tr, family = binomial)
diabetes.lr2
```

```{r}
summary(diabetes.lr2)
```

```{r}
diabetes.probs.2 <- predict(diabetes.lr2, Pima.te, type = "response")
head(diabetes.probs.2)
```

```{r}
diabetes.predict.2 <- rep("No", dim(Pima.te)[1])
diabetes.predict.2[diabetes.probs.2 > 0.5] <- "Yes"
head(diabetes.predict.2)
```

```{r}
table(diabetes.predict.2, Pima.te$type)
```

```{r}
length(diabetes.predict.2[diabetes.predict.2 == Pima.te$type])/dim(Pima.te)[1]
```

Adding bmi as a predictor did not improve the predictions by very much!
```{r}
lr.int <- -coef(diabetes.lr2)[1]/coef(diabetes.lr2)[3]
lr.slope <- -coef(diabetes.lr2)[2]/coef(diabetes.lr2)[3]
ggplot(Pima.tr, aes(x = glu, y = bmi)) + geom_point(aes(color = type)) +
    geom_abline(intercept = lr.int, slope = lr.slope)
```


### 9.1.2 More than two classes
Logistic regression methods also are applicable to classification contexts where there are more than two classes. Consider for example Fisher's iris data.
```{r}
data(iris)
head(iris)
```

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
    geom_point(aes(color = Species))
```

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width)) +
    geom_point(aes(color = Species))
```


Here the potential predictors are sepal width and length and petal width and length, and the goal is to find a classifier that will yield the correct species.

Before doing that we randomly choose 75 of the 150 rows of the data frame to be the training sample, with the other 75 being the test sample.
```{r}
set.seed(321)
selected <- sample(1:150, replace = FALSE, size = 75)
iris.train <- iris[selected, ]
iris.test <- iris[-selected, ]
```


There are several packages which implement logistic regression for data with more than two classes. We will use the VGAM package. The function vglm within VGAM implements logistic regression (and much more).

```{r}
library(VGAM)
iris.lr <- vglm(Species ~ Petal.Width + Petal.Length, data = iris.train, family = multinomial)

summary(iris.lr)
```


Notice that the family is specifed as `multinomial` rather than `binomial` since we have more than two classes. When run with these data, the `vglm` function returns several (about 20) warnings. These occur mainly because the classes are so easily separated, and are suppressed above.

Next we compute the probabilities for the test data.
```{r}
iris.probs <- predict(iris.lr, iris.test[, c(3, 4)], type = "response")
head(iris.probs)
```


For these, we want to choose the highest probability in each row.
```{r}
which.max(c(2, 3, 1, 5, 8, 3))
which.max(c(2, 20, 4, 5, 9, 1, 0))
class.predictions <- apply(iris.probs, 1, which.max)
head(class.predictions)
```

```{r}
class.predictions[class.predictions == 1] <- levels(iris$Species)[1]
class.predictions[class.predictions == 2] <- levels(iris$Species)[2]
class.predictions[class.predictions == 3] <- levels(iris$Species)[3]
head(class.predictions)
```

Next we create the confusion matrix.
```{r}
table(class.predictions, iris.test$Species)
```


## 9.2 Nearest neighbor methods
Nearest neighbor methods provide a rather different way to construct classifiers, and have strengths (minimal assumptions,  exible decision boundaries) and weaknesses (computational burden, lack of interpretability) compared to logistic regression models.

There are at least three R packages which implement `kNN`, including `class`, `kknn`, and `RWeka`. We will use `class` below.

```{r}
u.knn <- "http://blue.for.msu.edu/FOR875/data/knnExample.csv"
knnExample <- read.csv(u.knn, header=TRUE)
str(knnExample)
```

```{r}
ggplot(data = knnExample, aes(x = x1, y = x2)) +
    geom_point(aes(color = as.factor(class))) +
    theme_bw()
```

```{r}
expand.grid(x = c(1, 2), y = c(5, 3.4, 2))
```

```{r}
min(knnExample$x1)
max(knnExample$x1)
min(knnExample$x2)
max(knnExample$x2)
```

```{r}
x.test <- expand.grid(x1 = seq(-2.6, 4.2, by = 0.1), x2 = seq(-2, 2.9, by = 0.1))
```

```{r}
library(class)
Example_knn <- knn(knnExample[, c(1, 2)], x.test, knnExample[,3], k = 15, prob = TRUE)
prob <- attr(Example_knn, "prob")
head(prob)
```


```{r}
train <- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
test <- rbind(iris3[26:50,,1], iris3[26:50,,2], iris3[26:50,,3])
cl <- factor(c(rep("s",25), rep("c",25), rep("v",25)))
knn(train, test, cl, k = 3, prob=TRUE)
```


```{r}
library(dplyr)
df1 <- mutate(x.test, prob = prob, class = 0, prob_cls = ifelse(Example_knn == class, 1, 0))
str(df1)
```

```{r}
df2 <- mutate(x.test, prob = prob, class = 1, prob_cls = ifelse(Example_knn == class, 1, 0))
bigdf <- bind_rows(df1, df2)

names(knnExample)
```


```{r}
ggplot(bigdf) + 
    geom_point(aes(x = x1, y = x2, col = class),data = mutate(x.test, class = Example_knn), size = 0.5) +
    geom_point(aes(x = x1, y = x2, col = as.factor(class)), size = 4, shape = 1, data = knnExample) + 
    geom_contour(aes(x = x1, y = x2, z = prob_cls, group = as.factor(class), color = as.factor(class)), size = 1, bins = 1, data = bigdf) + 
    theme_bw()
```


```{r}
Example_knn <- knn(knnExample[, c(1, 2)], x.test, knnExample[,3], k = 1, prob = TRUE) 
prob <- attr(Example_knn, "prob")
head(prob)
```

```{r}
df1 <- mutate(x.test, prob = prob, class = 0, prob_cls = ifelse(Example_knn == class, 1, 0))
str(df1)
```

```{r}
df2 <- mutate(x.test, prob = prob, class = 1, prob_cls = ifelse(Example_knn == class, 1, 0))
bigdf <- bind_rows(df1, df2)
```

```{r}
ggplot(bigdf) + geom_point(aes(x = x1, y = x2, col = class), data = mutate(x.test, class = Example_knn), size = 0.5) +
    geom_point(aes(x = x1, y = x2, col = as.factor(class)), size = 4, shape = 1, data = knnExample) + 
    geom_contour(aes(x = x1, y = x2, z = prob_cls, group = as.factor(class), color = as.factor(class)), size = 1, bins = 1, data = bigdf) + 
    theme_bw()
```


### 9.2.1 kNN and the diabetes data
Next kNN is applied to the diabetes data. We will use the same predictors, `glu` and `bmi` that were used in the logistic regression example. Since the scales of the predictor variables are substantially different, they are standardized first. The value `k = 15` is chosen for kNN.

```{r}
Pima.tr[, 1:7] <- scale(Pima.tr[, 1:7], center = TRUE, scale = TRUE)
Pima.te[, 1:7] <- scale(Pima.te[, 1:7], center = TRUE, scale = TRUE)
knn_Pima <- knn(Pima.tr[, c(2, 5)], Pima.te[, c(2, 5)], Pima.tr[, 8], k = 15, prob = TRUE)
table(knn_Pima, Pima.te[, 8])
```


### 9.2.2 kNN and the iris data
Now kNN is used to classify the iris data. As before we use petal length and width as predictors

```{r}
sd(iris.train$Petal.Width)
sd(iris.train$Petal.Length)
head(iris.train)
```

```{r}
knn_iris <- knn(iris.train[, c(3, 4)], iris.test[, c(3, 4)], iris.train[, 5], k = 1, prob = TRUE)
table(knn_iris, iris.test[, 5])
```


```{r}
knn_iris <- knn(iris.train[, c(3, 4)], iris.test[, c(3, 4)], iris.train[, 5], k = 3, prob = TRUE)
table(knn_iris, iris.test[, 5])
```

```{r}
knn_iris <- knn(iris.train[, c(3, 4)], iris.test[, c(3, 4)], iris.train[, 5], k = 15, prob= TRUE)
table(knn_iris, iris.test[, 5])
```

# Text Data

## Examples of text data sets
    1. Enron email data set
    2. Play by play sports data (S.Hauschka 37 yd Field Goal)
    3. Unabomber Manifesto
    
Many applications require the ability to manipulate and process text data. For example, an email spam filter

## 10.1 Reading text data into R
Two functions to read in text data:

1. `scan` function - read data in from a file (more option)  
    `scan(file, what, sep)`  
    `what` is the variable type  
    `sep` is the deliminator (end of file line)  
    The notation for `sep` argument are:  
        `" "` for the space  
        `"\n"` for new line  
        `"\t"` for tab  
2. `readLines` function - to read url.

```{r}
u.email <- "http://blue.for.msu.edu/FOR875/data/email1.txt"
email1 <- scan(u.email, what = "character", sep = "")
length(email1)

email1[1:10]
```

```{r}
email1[1:10]
```

```{r}
email1 <- scan(u.email, what = "character", sep = "\n")
length(email1)
email1[1:10]
```


The `scan` function is quite flexible. In fact, `read.table` uses scan to actually read in the data. Read the help file for `scan` if more information is desired.

```{r}
u.moby <- "http://blue.for.msu.edu/FOR875/data/mobydick.txt"
moby_dick <- scan(u.moby, what = "character", sep = "\n")
moby_dick[1:25]
```

You will notice that scan function ignored blank lines in the file. If it is important to preserve blank lines, the argument `blank.lines.skip = FALS`E can be supplied to scan.

The file containing the novel contains some introductory and closing text that is not part of the original novel.

```{r}
moby_dick <- moby_dick[408:18576]
length(moby_dick)
```

## 10.2 The `paste` function
The `paste` function concatenates vectors after (if necessary) converting the vectors to character.

```{r}
paste("Homer Simpson", "is", "Bart Simpsons", "father")
```

```{r}
n <- 10
paste("The value of n is", n)
```

```{r}
paste(c("pig", "dog"), 3)
```

By default the paste function separates the input vectors with a space. But other separators can be specified

```{r}
paste("mail", "google", "com", sep = ".")
```

```{r}
paste(c("dog", "cat", "horse", "human", "elephant"), "food")
```

```{r}
paste(c("one", "two", "three", "four", "five"), c("six", "seven", "eight", "nine", "ten"))
```

To create one character element, we use `collapse`
This is the deliminator to combine into a single string with elements separated by specified values
```{r}
paste(c("one", "two", "three", "four", "five"), c("six", "seven", "eight", "nine", "ten"), collapse = ".")

paste(c("one", "two", "three", "four", "five"), c("six", "seven", "eight", "nine", "ten"), collapse = " ")
```

```{r}
paste(c("a", "b"), 1:10, sep = "")
```

Example when `paste` is useful:

```{r}
p <- c(500, 750, 1000)
n <- c(40, 50, 60)

for (i in p){
    for (j in n) {
        # code
        fname <- paste("result", "p", i, "n", n, ".txt", sep = "")
        print(fname)
        #write.table(file = fname)
    }
}
```


```{r}
# Create data:
a=c(1:5)
b=c(5,3,4,5,5)
c=c(4,5,4,3,1)
 
x=seq(1,10,length=100)
data=data.frame(x,dnorm(x,mean=6.5,sd=1))
names(data)=c('x','new.data')
x.ribbon=seq(1,10,length=20)
ribbon=data.frame(x.ribbon,
                  dnorm(x.ribbon,mean=5,sd=1)+.01,
                  dnorm(x.ribbon,mean=5,sd=1)-.01,
                  dnorm(x.ribbon,mean=5,sd=1))
names(ribbon)=c('x.ribbon','max','min','avg')

ggplot()+geom_ribbon(data=ribbon,aes(ymin=min,ymax=max,x=x.ribbon,fill='lightgreen'))+
    geom_line(data=ribbon,aes(x=x.ribbon,y=avg,color='black'))+
    geom_line(data=data,aes(x=x,y=new.data,color='red'))+
    xlab('x')+ylab('density') + 
    scale_fill_identity(name = 'the fill', guide = 'legend',labels = c('m1')) +
    scale_colour_manual(name = 'the colour', 
         values =c('black'='black','red'='red'), labels = c('c2','c1'))
 
```










